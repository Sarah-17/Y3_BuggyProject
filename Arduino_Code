//Set up the username and password for the WAP
#include <WiFiNINA.h>
char ssid[] = "TeamY3"; 
char pass[] = "#icecream"; 

WiFiServer server(5200);

const int RMOTOR_1 = 9; //S1
const int RMOTOR_2 = 10; //S3
const int LMOTOR_1 = 6; //S2
const int LMOTOR_2 = 5; //S4

//pins controlling the speed of the car
// the left and right are given the same pins as it makes sense for them to be moving at the same speed
// Can switch one to i.e., pin 17 which is close to it
const int L_pwm = 16; 
const int R_pwm = 17;

/*
const int LEYE = A5;
const int REYE = A4;
const int US_TRIG = 2;
const int US_ECHO = 3; */

const int LEYE = 18;
const int REYE = 14;
const int US_TRIG = 2;
const int US_ECHO = 3;


volatile int distance; //travel time * speed of the echo / 2
volatile long duration; //used to read the travel time of the echo;
char curr_state = 'n';
char dist;
//char old_state = 'y';
int L_Sensor;
int R_Sensor;

void setup() {
  //Sets the serial baud rate
  Serial.begin(9600);

  WiFi.beginAP(ssid, pass); 
  IPAddress ip = WiFi.localIP(); 
  Serial.print("IP Address:"); 
  Serial.println(ip);  //prints arduino's IP to connect the Processing client
  server.begin();

  //Ultrasonic Sensors
  pinMode(US_TRIG, OUTPUT);
  pinMode(US_ECHO, INPUT);
  

  //pinMode(US_ECHO, INPUT_PULLUP);
  //attachInterrupt(digitalPinToInterrupt(US_ECHO), check_distance, CHANGE);

  //IR Sensors
  pinMode(LEYE, INPUT);
  pinMode(REYE, INPUT);

  pinMode(LEYE, INPUT_PULLUP);  
  attachInterrupt(digitalPinToInterrupt(LEYE), state, CHANGE);
  pinMode(REYE, INPUT_PULLUP);  
  attachInterrupt(digitalPinToInterrupt(REYE), state, CHANGE);


  pinMode(LMOTOR_1, OUTPUT);
  pinMode(LMOTOR_2, OUTPUT);
  pinMode(RMOTOR_1, OUTPUT);
  pinMode(RMOTOR_2, OUTPUT);

  breaks();

}


void loop() {
  //Stores inputs from IR sensors in the variables
  L_Sensor = digitalRead(LEYE);
  R_Sensor = digitalRead(REYE);

  WiFiClient client = server.available(); 
  
  if (client.connected()) { 
    Serial.println("Client connected");
    
      //read request from controller
      curr_state = client.read();
  
      if(curr_state == 'y'){
        Serial.println("Starting motor");
        forwards();   
      }

      else if(curr_state == 'n'){
        Serial.println("Stopping motor");
        breaks();          
      }
  }

  if(curr_state != 'n'){
    
    state();
    check_distance();
    if(distance < 10 ){
      //inform controller of obstacle ahead.
      client.write('o');
    }
  }
}
  
void state(){
  
    if((L_Sensor == HIGH) && (R_Sensor == HIGH)){//implies that the car has steered to the right
        //solution: steer it to the left
      forwards();   
    }
    //0 - detects black line, 1 - does not detect black line
    if((L_Sensor == HIGH) && (R_Sensor == LOW)){//implies that the car has steered to the right
      //solution: steer it to the left
      turnRight();   
      Serial.println("Turning right");
    }
    if((L_Sensor == LOW) && (R_Sensor == HIGH)){//implies that the car has steered to the left
      //solution: steer it to the left  
      turnLeft(); 
      Serial.println("Turning left");
    }
    if((L_Sensor == LOW) && (R_Sensor == LOW)){//implies that the car has steered to the right
        //solution: steer it to the left
      forwards();   
    }
}

//Checks for any obstacles around 10cm or less ahead
void check_distance(){
  
  digitalWrite(US_TRIG, LOW);
  delayMicroseconds(2);

  digitalWrite(US_TRIG, HIGH);
  delayMicroseconds(10);
  digitalWrite(US_TRIG, LOW);

  duration = pulseIn(US_ECHO, HIGH);
  int distance = duration/58;


  if(distance < 10){
    breaks(); 
    //Serial.println("Obstacle detected about 10cm away!");
  }

  delay(500);
}

//Motor functions for speed and direction
void forwards()
{
  analogWrite(LMOTOR_1, 183); // analogWrite allows us choose what voltage we send to the motor, instead of digitalWrite which is either full power or sero power
  analogWrite(LMOTOR_2, 0);
  analogWrite(RMOTOR_1, 190); // the right motor is slightly slower than the left one due to friction/wear/etc... so we give it a higher voltage than the left one (ie its been calibrated)
  analogWrite(RMOTOR_2, 0);
}

void reverse()
{
  analogWrite(LMOTOR_1, 0);
  analogWrite(LMOTOR_2, 183);
  analogWrite(RMOTOR_1, 0);
  analogWrite(RMOTOR_2, 190);
}

void breaks()
{
  analogWrite(LMOTOR_1, 0);
  analogWrite(LMOTOR_2, 0);
  analogWrite(RMOTOR_1, 0);
  analogWrite(RMOTOR_2, 0);
}

void turnRight()
{
  analogWrite(LMOTOR_1, 183);
  analogWrite(LMOTOR_2, 0);
  analogWrite(RMOTOR_1, 110);
  analogWrite(RMOTOR_2, 0);
}

void turnLeft()
{
  analogWrite(LMOTOR_1, 103);
  analogWrite(LMOTOR_2, 0);
  analogWrite(RMOTOR_1, 190);
  analogWrite(RMOTOR_2, 0);
}
